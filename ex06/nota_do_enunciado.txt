ğŸ¯ Objetivo principal (de forma curta);
    Implementar uma funÃ§Ã£o que conte o nÃºmero de caracteres de uma string sem usar funÃ§Ãµes externas, reforÃ§ando o entendimento de ponteiros, arrays e controle de fluxo.

âœ… Pontos positivos:
    - Treina lÃ³gica bÃ¡sica de contagem e estrutura de repetiÃ§Ã£o.
    - Evita dependÃªncia de biblioteca (strlen da <string.h>), Ãºtil em ambientes restritos.
    - Fortalece entendimento de strings como arrays de char terminados por '\0'.
    - Simples e eficiente, ideal para iniciantes e validaÃ§Ã£o de fundamentos.

âš ï¸ Pontos negativos:
    - NÃ£o trata ponteiro nulo (NULL) â€” pode causar falha se str == NULL.
    - NÃ£o verifica limites de seguranÃ§a (como tamanho mÃ¡ximo).
    - NÃ£o Ã© reutilizÃ¡vel para substrings ou buffers parciais sem adaptaÃ§Ã£o.

ğŸ› ï¸ Quando usar esse mecanismo:
    - Ao implementar sua prÃ³pria biblioteca padrÃ£o (libft).
    - Em projetos onde funÃ§Ãµes externas sÃ£o proibidas (como na 42).
    - Em sistemas embarcados ou ambientes com restriÃ§Ã£o de recursos.
    - Para validar entrada, calcular tamanho antes de alocar memÃ³ria ou copiar strings.

ğŸ§ª 3 Enunciados para praticar e aprofundar:
    1. ft_strlen_safe
    Escreva uma funÃ§Ã£o que conte os caracteres de uma string apenas se o ponteiro nÃ£o for nulo, retornando 0 em caso contrÃ¡rio.
    int ft_strlen_safe(char *str);
    
    2. ft_strlen_until
    Escreva uma funÃ§Ã£o que conte os caracteres de uma string atÃ© encontrar um caractere especÃ­fico (ex: ',' ou '.').
    int ft_strlen_until(char *str, char stop);
    
    3. ft_strlen_range
    Escreva uma funÃ§Ã£o que conte os caracteres entre dois Ã­ndices (start e end) de uma string, sem ultrapassar o '\0'.
    int ft_strlen_range(char *str, int start, int end);