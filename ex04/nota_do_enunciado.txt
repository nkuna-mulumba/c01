üéØ Breve objetivo do enunciado:
    O exerc√≠cio prop√µe a cria√ß√£o de uma fun√ß√£o que recebe dois ponteiros para inteiros e realiza uma divis√£o inteira, armazenando:
    - O quociente no primeiro ponteiro (*a)
    - O resto no segundo ponteiro (*b)
    - O objetivo √© treinar:
    - Manipula√ß√£o de ponteiros
    - Opera√ß√µes aritm√©ticas b√°sicas
    - Atualiza√ß√£o de valores via refer√™ncia

‚úÖ Pontos positivos:
    - Clareza na prototipagem: uso direto de void ft_ultimate_div_mod(int *a, int *b);
    - Foco em ponteiros: refor√ßa a compreens√£o de como modificar vari√°veis fora do escopo local
    - Sem fun√ß√µes externas: exige racioc√≠nio puro com operadores nativos (/, %)
    - Pr√°tico e direto: simula uma opera√ß√£o comum em algoritmos matem√°ticos

‚ö†Ô∏è Pontos negativos:
    - N√£o exige verifica√ß√£o de divis√£o por zero: pode induzir a erros se usado sem cuidado
    - Pouca contextualiza√ß√£o: n√£o mostra onde esse tipo de fun√ß√£o seria √∫til em sistemas reais
    - N√£o permite retorno de erro ou status: limita a robustez da fun√ß√£o

üõ†Ô∏è Quando esse mecanismo √© √∫til em projetos:
    - Fun√ß√µes matem√°ticas internas: como em calculadoras, conversores ou sistemas de pontua√ß√£o
    - Manipula√ß√£o de dados em baixo n√≠vel: quando se quer evitar retorno por return e usar ponteiros para m√∫ltiplos resultados
    - Sistemas embarcados ou drivers: onde economia de mem√≥ria e controle direto s√£o essenciais
    - Rotinas de parsing ou formata√ß√£o: como extrair d√≠gitos ou separar partes de um n√∫mero

üß™ Enunciados pr√°ticos para aprofundar o conceito:
    - 1. ft_swap_values
        Escreva uma fun√ß√£o que receba dois ponteiros para inteiros e troque os valores entre eles.
        void ft_swap_values(int *a, int *b);
    - 2. ft_split_sum
        Crie uma fun√ß√£o que receba dois inteiros e dois ponteiros. Armazene a soma dos inteiros em um ponteiro e a diferen√ßa no outro.
        void ft_split_sum(int a, int b, int *sum, int *diff);
    - 3. ft_extract_digits
        Escreva uma fun√ß√£o que receba um inteiro positivo e dois ponteiros. Armazene o √∫ltimo d√≠gito em um ponteiro e o restante do n√∫mero no outro.
        void ft_extract_digits(int n, int *last_digit, int *rest);
