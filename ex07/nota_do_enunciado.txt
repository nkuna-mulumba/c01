ğŸ¯ Breve objetivo do enunciado
    O exercÃ­cio propÃµe implementar uma funÃ§Ã£o que inverta os elementos de um array de inteiros, sem usar funÃ§Ãµes externas. O primeiro elemento troca com o Ãºltimo, o segundo com o penÃºltimo, e assim por diante.

    Essa operaÃ§Ã£o Ã© feita in-place, ou seja, sem criar um novo array â€” apenas trocando os valores dentro do original.

âœ… Pontos positivos da resoluÃ§Ã£o:
    - Simples e eficiente: usa apenas uma variÃ¡vel temporÃ¡ria (tmp) e um loop com Ã­ndice i.
    - Evita alocaÃ§Ã£o dinÃ¢mica: ideal para ambientes com restriÃ§Ãµes de memÃ³ria.
    - Boa prÃ¡tica de manipulaÃ§Ã£o de ponteiros e Ã­ndices.
    - Evita funÃ§Ãµes externas: cumpre o requisito de nÃ£o usar funÃ§Ãµes autorizadas.

âš ï¸ Pontos negativos ou limitaÃ§Ãµes
    - Sem validaÃ§Ã£o de ponteiro nulo: nÃ£o verifica se tab == NULL.
    - NÃ£o trata arrays de tamanho zero ou negativo: embora size / 2 evite erro, seria bom validar.
    - NÃ£o imprime ou testa o resultado: Ãºtil para depuraÃ§Ã£o.
    - NÃ£o modulariza: tudo estÃ¡ em uma funÃ§Ã£o Ãºnica, sem separaÃ§Ã£o de responsabilidades.

ğŸ§  Quando aplicar esse tipo de mecanismo?
    - Esse tipo de inversÃ£o Ã© Ãºtil em:
    - Algoritmos de ordenaÃ§Ã£o ou reorganizaÃ§Ã£o de dados
    - ManipulaÃ§Ã£o de buffers (ex: inverter sequÃªncia de bytes)
    - FunÃ§Ãµes de reversÃ£o de strings ou arrays (ex: reverse() em linguagens de alto nÃ­vel)
    - SoluÃ§Ãµes de problemas matemÃ¡ticos (ex: palÃ­ndromos, simetria)
    - PrÃ©-processamento de dados (ex: inverter logs, histÃ³rico, etc.)

ğŸ§ª 3 Enunciados prÃ¡ticos para treinar esse mecanismo
    1. ğŸ”„ Inverter uma string de caracteres
    void ft_rev_str(char *str);
    Recebe uma string e inverte os caracteres in-place, sem usar funÃ§Ãµes externas.

    2. ğŸ§® Inverter um array de floats
    void ft_rev_float_tab(float *tab, int size);
    Mesma lÃ³gica, mas com float. Ideal para treinar com tipos diferentes e precisÃ£o.

    3. ğŸ§© Inverter pares em um array
    void ft_rev_pairs(int *tab, int size);
    Inverte os elementos de dois em dois: [1,2,3,4] â†’ [2,1,4,3]. Exige controle de Ã­ndices e lÃ³gica condicional.