ğŸ¯ Objetivo do enunciado:
    Criar uma funÃ§Ã£o que ordene um array de inteiros em ordem crescente, usando apenas lÃ³gica bÃ¡sica (sem funÃ§Ãµes externas), com controle manual de Ã­ndices e trocas.

âœ… Pontos positivos da tua soluÃ§Ã£o:
    - NÃ£o usa funÃ§Ãµes externas: segue a restriÃ§Ã£o do exercÃ­cio.
    - Simples e legÃ­vel: ideal para iniciantes entenderem lÃ³gica de ordenaÃ§Ã£o.
    - Robusta para arrays pequenos: funciona bem com 3, 5, 10 elementos.

âš ï¸ Pontos negativos (limitaÃ§Ãµes)
    - Desempenho fraco em arrays grandes: Bubble Sort tem complexidade O(nÂ²).
    - Trocas desnecessÃ¡rias: mesmo com array quase ordenado, percorre tudo.
    - NÃ£o Ã© estÃ¡vel nem adaptativo: nÃ£o aproveita ordenaÃ§Ãµes parciais com eficiÃªncia.
    - NÃ£o permite ordenaÃ§Ãµes personalizadas (ex: decrescente, por critÃ©rios) sem modificar a lÃ³gica.
 
ğŸ§  Quando aplicar esse mecanismo em projetos
    - Em projetos educacionais ou exercÃ­cios de lÃ³gica.
    - Para ordenar arrays pequenos onde desempenho nÃ£o Ã© crÃ­tico.
    - Em ambientes restritos (sem acesso a qsort, sort, etc.).
    - Para testes manuais ou validaÃ§Ã£o de funÃ§Ãµes com dados simples.

ğŸ“˜ Enunciados para treinar e entender melhor esse tipo de mecanismo:
    1. Ordenar um array de floats em ordem decrescente
        // Exemplo: [1.2, 3.4, 2.1] â†’ [3.4, 2.1, 1.2]
        Treina adaptaÃ§Ã£o de tipos e lÃ³gica inversa.

    2. Ordenar apenas os elementos pares de um array, mantendo Ã­mpares nas posiÃ§Ãµes
        // Exemplo: [4, 3, 2, 1] â†’ [2, 3, 4, 1]
        Exige controle condicional e manipulaÃ§Ã£o seletiva.

    3. Detectar se um array jÃ¡ estÃ¡ ordenado antes de aplicar Bubble Sort. Se estiver ordenado, nÃ£o faz nada.